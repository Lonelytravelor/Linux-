# 进程优先级

首先进行比较粗糙的划分,进程可以分为实时进程和非实时进程。

# 1. 进程分类

## 1.1 硬实时进程

**硬实时进程有严格的时间限制,某些任务必须在指定的时限内完成。**

> 如果飞机的飞行控制命令通过计算机处理,则必须尽快处理发送,即保证在确定的一段时间内完成。
>
> 例如,如果飞机处于着陆进场过程中,而飞行员想要拉起机头。
>
> 如果计算机在几秒以后发送该命令,则什么用也没有!此时只能考虑飞机的后事了——一头扎到地上。

- 硬实时进程的关键特征是,它们**必须在可保证的时间范围内得到处理。**

> 请注意,这并不意味着所要求的时间范围特别短, 而是系统必须保证决不会超过某一时间范围,即使在不大可能或条件不利的情况下也是如此。

- **Linux不支持硬实时处理,至少在主流的内核中不支持。**

> 但有一些修改版本如RTLinux、Xenomai、RATI提供了该特性。
>
> 在这些修改后的方案中,Linux内核作为独立的"进程"运行来处理次重要的软件,而实时的工作则在内核外部完成。

- 由于Linux是针对吞吐量优化,试图尽快地处理常见情形,其实很难实现可保证的响应时间。

> 2007年我们在降低内核整体延迟(指向内核发出请求到完成之间的时间间隔)方面取得了相当多的进展。相关工作包括:可抢占的内核机制、实时互斥量以及本书将要讨论的完全公平的新调度器。

## 1.2 软实时进程

**软实时进程是硬实时进程的一种弱化形式。**

> 尽管仍然需要快速得到结果,但稍微晚一点不会造成世界末日。

- 软实时进程的一个例子是对CD的写入操作。

> CD写入进程接收的数据必须保持某一速率,因为数据是以连续流的形式写入介质的。
>
> 如果系统负荷过高,数据流可能会暂时中断,这可能导致CD不可用,但比坠机好得多。
>
> 不过,写入进程在需要CPU时间时应该能够得到保证,至少优先于所有其他普通进程。

## 1.3 普通进程

大多数进程是没有特定时间约束的普通进程,但仍然可以**根据重要性来分配优先级**。

> 例如,冗长的编译或计算只需要极低的优先级,因为计算偶尔中断一两秒根本不会有什么后果, 用户不太可能注意到。
>
> 相比之下, 交互式应用则应该尽快响应用户命令, 因为用户很容易不耐烦

# 2. 抢占式多任务处理(preemptive multitasking)

进程的运行按时间片调度,分配给进程的时间片份额与其相对重要性相当。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDFkZmM4ZmY5MTk0YjJkYWY3MDViZTQ3YWNlNmMwOWZfNmJjb1VFOVZIaTdqdVVvNXVwYUNPdjJFQklZWEVVWUZfVG9rZW46R3ltSmJkYkJFbzFEVUd4blNURGN5SERFbldkXzE3MDQ0Mzg1NTI6MTcwNDQ0MjE1Ml9WNA)

系统中时间的流动对应于圆盘的转动,而CPU则由圆周旁的"扫描器"表示。

最终效果是,尽管所有的进程都有机会运行,但重要的进程会比次要的得到更多的CPU时间。

这种方案称之为**抢占式多任务处理(preemptive multitasking)** ,各个进程都分配到一定的时间段可以执行。

- 时间段到期后,内核会从进程收回控制权,让一个不同的进程运行,而不考虑前一进程所执行的上一个任务。
- 被抢占进程的运行时环境,即所有CPU寄存器的内容和页表,都会保存起来,因此其执行结果不会丢失。
-  在该进程恢复执行时,其进程环境可以完全恢复。
- 时间片的长度会根据进程重要性(以及因此而分配的优先级)的不同而变化。

这种简化模型没有考虑**几个重要问题**：

- 例如, 进程在某些时间可能因为无事可做而无法立即执行。

为使CPU时间的利益回报尽可能最大化,这样的进程决不能执行。

- 另外一个忽略的事实是Linux支持不同的调度类别
- 此外,在有重要的进程变为就绪状态可以运行时,有一种选项是抢占当前的进程

# 3. 进程调度

另外调度器要满足Linux系统上许多不同工作负荷所提出的需求,这是非常具有挑战性的。

> 自动化控制所需的小型嵌入式系统和大型计算机的需求非常不同,而多媒体系统的需求与前两者也颇为不同。实际上,调度器的代码近年来已经重写了两次。

## 3.1  O(1)调度器

在2.5系列内核开发期间,所谓的 O(1)调度器代替了前一个调度器。

该调度器一个特别的性质是,它可以在常数时间内完成其工作,不依赖于系统上运行的进程数目。

## 3.2 完全公平调度器(completely fair scheduler)

完全公平调度器(completely fair scheduler)在内核2.6.23开发期间合并进来。

完全公平调度器的代码再一次完全放弃了原有的设计原则,例如,前一个调度器中为确保用户交互任务响应快速,需要许多启发式原则。

调度器的**关键特性**是**,它试图尽可能地模仿理想情况下的公平调度**。

此外,它不仅可以调度单个进程, 还能够处理更一般性的调度实体 (scheduling entity) 。

> 例如, 该调度器分配可用时间时, 可以首先在不同用户之间分配,接下来在各个用户的进程之间分配。