本节概述了内核的各个组成部分。

尽管Linux是整体式的宏内核,但其具有相当良好的结构。尽管如此,Linux内核各个组成部分之间的彼此交互是不可避免的。

各部分会共享数据结构,而且与严格隔离的系统相比,各部分(因为性能原因)协同工作时需要更多的函数。

在后续章节中,尽管我试图将向前引用的次数降至最低,但也不得不经常引用内核的其他组成部分(即其他章节) 。

为此我会在这里简短介绍各个组成部分,使读者能对各个部分在内核整体结构中的作用和地位有一定的印象。

图1-1是一个粗略的草图,概述了组成完整Linux系统的各个层次,以及内核所包含的一些重要子系统。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=NzY5YjI4M2U0NjA4YjIwZjU0MTQwNjIxOGVmODNiYzlfVnAxWkNhOUR4TW5NbTh2azVmaTJ4cGxoV21abU05N2tfVG9rZW46WFp1d2J2U3kwb2ZBUkh4SEVxR2NZaklObnNoXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

# 1. 进程、进程切换、调度

**传统上,UNIX操作系统下运行的应用程序、服务器及其他程序都称为进程。**

- 每个进程都在CPU 的虚拟内存中分配地址空间。
- 各个进程的地址空间是完全独立的, 因此进程并不会意识到彼此的存在。
- 从进程的角度来看,它会认为自己是系统中唯一的进程。
- 如果进程想要彼此通信(例如交换数据) , 那么必须使用特定的内核机制。

**由于Linux是多任务系统,它支持(看上去)并发执行的若干进程。**

> 系统中同时真正在运行的进程数目最多不超过CPU数目,因此内核会按照短的时间间隔在不同的进程之间切换(用户是注意不到的) ,这样就造成了同时处理多进程的假象。

这里有两个问题：

1. 内核借助于CPU的帮助,负责进程切换的技术细节。
   1. 必须给各个进程造成一种错觉,即CPU 总是可用的。
   2. 通过在撤销进程的CPU资源之前保存进程所有与状态相关的要素,并将进程置于空闲状态,即可达到这一目的。
   3. 在重新激活进程时,则将保存的状态原样恢复。进程之间的切换称之为进程切换。
2. 内核还必须确定如何在现存进程之间共享CPU时间。
   1. 重要进程得到的CPU时间多一点,次要进程得到的少一点。确定哪个进程运行多长时间的过程称为调度。

# 2. UNIX进程

**Linux对进程采用了一种层次系统,每个进程都依赖于一个父进程。**

内核启动init程序作为第一个进程,该进程负责进一步的系统初始化操作,并显示登录提示符或图形登录界面。

> 因此init是进程树的根,所有进程都直接或间接起源自该进程,如下面的pstree程序的输出所示。其中init是一个树型结构的顶端,而树的分支不断向下扩展。
>
> ![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=MWM4YmYzMzViZWVjNjhlOThjM2YwMzY5OTFmNmRkZjFfbmlwR2dTZGN3a1cxdlNPSDIxSDB5STZJR01XazZGTnpfVG9rZW46VlZreGJaTXNib0dwcTl4UEJ3aWNjSFFWbnFoXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

**该树型结构的扩展方式与新进程的创建方式密切相关。**

UNIX操作系统中有两种创建新进程的机制,分别是fork和exec。

1. fork可以创建当前进程的一个副本,父进程和子进程只有PID(进程ID)不同。
   1. 在该系统调用执行之后,系统中有两个进程,都执行同样的操作。
   2. 父进程内存的内容将被复制,至少从程序的角度来看是这样。
   3. Linux使用了一种众所周知的技术来使fork操作更高效, 该技术称为写时复制 (copy on write),主要的原理是将内存复制操作延迟到父进程或子进程向某内存页面写入数据之前,在只读访问的情况下父进程和子进程可以共用同一内存页。
2. exec将一个新程序加载到当前进程的内存中并执行。
   1. 旧程序的内存页将刷出,其内容将替换为新的数据。然后开始执行新程序

## 2.1 线程

**进程并不是内核支持的唯一一种程序执行形式。**

除了重量级进程(有时也称为UNIX进程)之外, 还有一种形式是线程(有时也称为轻量级进程)。

> 线程也已经出现相当长的一段时间,本质上一个进程可能由若干线程组成,这些线程共享同样的数据和资源,但可能执行程序中不同的代码路径。
>
> 线程概念已经完全集成到许多现代编程语言中,例如Java

简而言之,进程可以看作一个正在执行的程序, 而线程则是与主程序并行运行的程序函数或例程。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=M2UyYzZlZTgyOGNkYTBhNzY2YTk2NWQ3YWZjZDBhMzlfam1CWFRMRnFkRzJ3U0lKa3dqU0hqQmpYOGtkZ0psbklfVG9rZW46R2s5V2JpNk1Rb1IwWkh4RHppZ2MyeWhhbjRmXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

> 该特性是有用的,例如在浏览器需要并行加载若干图像时，通常浏览器只好执行几次fork和exec调用,以此创建若干并行的进程实例。
>
> 这些进程负责加载图像, 并使用某种通信机制将接收的数据提供给主程序。
>
> 在使用线程时, 这种情况更容易处理一些。 浏览器定义了一个例程来加载图像,可以将例程作为线程启动,使用参数不同的多个线程即可。
>
> 由于线程和主程序共享同样的地址空间,主程序自动就可以访问接收到的数据。因此除了为防止线程访问同一内存区而采取的互斥机制外, 就不需要什么通信了。

Linux用clone方法创建线程

其工作方式类似于fork,但启用了精确的检查,以确认哪些资源与父进程共享、哪些资源为线程独立创建。

这种细粒度的资源分配扩展了一般的线程概念,在一定程度上允许线程与进程之间的连续转换。

## 2.2 命名空间

在内核2.6的开发期间,对命名空间的支持被集成到了许多子系统中，**这使得不同的进程可以看到不同的系统视图。**

传统的Linux(与一般的UNIX操作系统)使用许多全局量,例如进程ID。

> 每个进程都有一个唯一标识符(ID) ,用户(或其他进程)可使用ID来访问进程,例如向进程发一个信号。

启用命名空间之后,以前的全局资源现在具有不同分组。

> 每个命名空间可以包含一个特定的PID集合,或可以提供文件系统的不同视图,在某个命名空间中挂载的卷不会传播到其他命名空间中。

命名空间很有用处

1. 举例来说,该特性对虚拟主机供应商是有益的。
   1. 他们不必再为每个用户准备一台物理计算机,而是通过称为容器的命名空间来建立系统的多个视图。
2. 从容器内部看来这是一个完整的Linux系统, 而且与其他容器没有交互。
   1. 容器是彼此分离的。
   2. 每个容器实例看起来就像是运行Linux 的一台计算机,但事实上一台物理机器可以同时运转许多这样的容器实例。
   3. 这有助于更有效地使用资源。
   4. 与完全的虚拟化解决方案(如KVM)相比,计算机上只需要运行一个内核来管理所有的容器。

并非内核的所有部分都完全支持命名空间, 在分析各个子系统时,我会讨论相应子系统对命名空间的支持程度。

# 3. 地址空间与特权级别

**在开始讨论虚拟地址空间之前,我们需要修订一些符号约定。**

在本书中,我使用缩写KiB、MiB 和GiB作为容量单位,分别表示2的十次方、2的20次方、2的30次方字节。

由于内存区域是通过指针寻址,因此CPU的字长决定了所能管理的地址空间的最大长度。

> 对32位系统(如IA-32、PPC、m68k) ,是232B=4GiB,对更现代的64位处理器(如Alpha、Sparc64、IA-64、AMD64) ,可以管理264B。

**地址空间的最大长度与实际可用的物理内存数量无关,因此被称为虚拟地址空间。**

- 使用该术语的另一个理由是,从系统中每个进程的角度来看,地址空间中只有自身一个进程,而无法感知到其他进程的存在。
- 应用程序无需关注其他程序的存在,好像计算机中只有一个进程一样。

**Linux将虚拟地址空间划分为两个部分,分别称为内核空间和用户空间。**

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=M2VlNDU3ZTVmZDBlYjU5MmUyZGFjMjE1MmM4MWUyNzlfUTdjYklCdklzcnlhMkp1elRJbkFYNmhOSHI1VlVsOHpfVG9rZW46WTdtd2JNTnpHb2F0S054VmJreWNrZk51bkRjXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

- 系统中每个用户进程都有自身的虚拟地址范围,从0到TASK_SIZE。
- 用户空间之上的区域(从TASK_SIZE到232或264)保留给内核专用,用户进程不能访问。
- TASK_SIZE是一个特定于计算机体系结构的常数,把地址空间按给定比例划分为两部分。

> 例如在IA-32系统中,地址空间在3 GiB处划分,因此每个进程的虚拟地址空间是3 GiB。
>
> 由于虚拟地址空间的总长度是4 GiB, 所以内核空间有1 GiB可用。
>
> 尽管实际的数字依不同的计算机体系结构而不同,但一般概念都是相同的。因此我在进一步讨论中将使用例子中的这些值。

**这种划分与可用的内存数量无关**

由于地址空间虚拟化的结果, 每个用户进程都认为自身有3 GiB 内存。

各个系统进程的用户空间是完全彼此分离的。

而虚拟地址空间顶部的内核空间总是同样的,无论当前执行的是哪个进程。

**注意,64位计算机的情况可能更复杂**

- 因为它们在实际管理自身巨大的理论虚拟地址空间时,倾向于使用小于64的位数。因此,地址空间中实际可寻址的部分小于理论长度。
- 但无论如何,该值仍然大于计算机上实际可能的内存数量,因此是完全够用的。实际使用的位数一般小于64位,如42位或47位。

这种做法的一个优点是与寻址完整的虚拟地址空间相比,管理有效地址空间所需的位数较少, 因此CPU可以节省一些工作量。

这样,虚拟地址空间会包含一些不可寻址的洞,所以图1-3描述的简单情况是不完全正确的。我们将在第4章更详细地讨论该主题。

## 3.1 特权级别

**内核把虚拟地址空间划分为两个部分,因此能够保护各个系统进程,使之彼此隔离。**

1. 所有的现代CPU都提供了几种特权级别,进程可以驻留在某一特权级别。
2. 每个特权级别都有各种限制,例如对执行某些汇编语言指令或访问虚拟地址空间某一特定部分的限制。
3. IA-32体系结构使用4种特权级别构成的系统,各级别可以看作是环。内环能够访问更多的功能,外环则较少,如图1-4所示。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=MmNhYWVkZjA1ZmNhNzM1NGM2ZWJmZWVlYTMyM2IzZDRfMDFJMjNLb2ZFdzJpd0VlTU8yWUJEcU4ySHVwOVh4ZTBfVG9rZW46WUtLSmI0M09rb3NVdUN4eTJDMWNha2RqbmlnXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

尽管英特尔处理器区分4种特权级别,但Linux只使用两种不同的状态：核心态和用户状态。

两种状态的关键差别在于对高于TASK_SIZE的内存区域的访问。

- 简而言之, 在用户状态禁止访问内核空间。
- 用户进程不能操作或读取内核空间中的数据,也无法执行内核空间中的代码。
- 这是内核的专用领域。

这种机制可防止进程无意间修改彼此的数据而造成相互干扰。

**从用户状态到核心态的切换通过系统调用的特定转换手段完成, 且系统调用的执行因具体系统而不同。**

> 如果普通进程想要执行任何影响整个系统的操作(例如操作输入/输出装置),则只能借助于系统调用向内核发出请求。
>
> 内核首先检查进程是否允许执行想要的操作, 然后代表进程执行所需的操作, 接下来返回到用户状态

**除了代表用户程序执行代码之外,内核还可以由异步硬件中断激活,然后在中断上下文中运行。**

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=NWU5NDVhMTNlNGE2ODRhNmQxYjM4MDA5Y2Q4NDE3MDhfZVRFMGdrSDNJdEFxcGNCajZ1dmROanFPQnRJQVJydmtfVG9rZW46VTdHZ2JPRW5Db2hFdVN4YkFWemNUZE1PbnhkXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

- CPU大多数时间都在执行用户空间中的代码。
- 当应用程序执行系统调用时,则切换到核心态,内核将完成其请求。在此期间,内核可以访问虚拟地址空间的用户部分。
- 系统调用完成之后,CPU切换回用户状态。
- 硬件中断也会使CPU切换到核心态,这种情况下内核不能访问用户空间

> 与在进程上下文中运行的主要区别是,在中断上下文中运行不能访问虚拟地址空间中的用户空间部分。
>
> 因为中断可能随机发生,中断发生时可能是任一用户进程处于活动状态,由于该进程基本上与中断的原因无关,因此内核无权访问当前用户空间的内容。
>
> 在中断上下文中运行时,内核必须比正常情况更加谨慎,例如,不能进入睡眠状态。

**除了普通进程,系统中还有内核线程在运行。**

内核线程也不与任何特定的用户空间进程相关联, 因此也无权处理用户空间。

不过在其他许多方面,内核线程更像是普通的用户层应用程序。

与在中断上下文运转的内核相比, 内核线程可以进入睡眠状态, 也可以像系统中的普通进程一样被调度器跟踪。

内核线程可用于各种用途:

- 内存和块设备之间的数据同步
- 帮助调度器在CPU上分配进程。

请注意,在ps命令的输出中很容易识别内核线程,其名称都置于方括号内：

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDdjY2RlYzljNzI1OTI4YWQwNTJkMjExMjdjMzY1NDhfUGlYQ2IyMjA0M0RPWnF2VXdlcGVuYVUzRHM5TjByaWRfVG9rZW46TElwS2IzNXlPb1FPbmF4RW1WTmNCUmtYbmRjXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

在多处理器系统上,许多线程启动时指定了CPU,并限制只能在某个特定的CPU上运行。

从内核线程名称之后的斜线和CPU编号可以看到这一点。

## 3.2 虚拟和物理地址空间

**什么是虚拟地址？**

详细请参考：[虚拟地址是什么？什么是虚拟地址空间？](https://xiaomi.f.mioffice.cn/docs/dock4IJ2tzJSCcQu4ATYRjT2q7g) 

**大多数情况下, 单个虚拟地址空间就比系统中可用的物理内存要大。**

在每个进程都有自身的虚拟地址空间时,情况也不会有什么改善。

因此内核和CPU必须考虑如何将实际可用的物理内存映射到虚拟地址空间的区域。

**可取的方法是用页表来为物理地址分配虚拟地址。**

虚拟地址关系到进程的用户空间和内核空间, 而物理地址则用来寻址实际可用的内存。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=MGYzZjc5ZDEwZDNkOGRmYTA1YmJlYTljZTg4YTA3NGNfamhIRFRZNjIyVmU4S1VZQlNLVlFTRWk4cWhoeGVLelVfVG9rZW46UHBmNmI2T2JwbzdyRGl4V1ZxTWMzZVY5bk1lXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

> 图1-6中的箭头标明了虚拟地址空间中的页如何分配到物理内存页。
>
> 例如,进程A的虚拟内存页1 映射到物理内存页4,而进程B的虚拟内存页1映射到物理内存页5。
>
> 由此可见,不同进程的同一虚拟地址实际上具有不同的含义。

图中所示两个进程的虚拟地址空间,都被内核划分为很多等长的部分。这些部分称之为页。物理内存也划分为同样大小的页。

 物理内存页经常称作页帧。相比之下,页则专指虚拟地址空间中的页。

**虚拟地址空间和物理内存之间的映射也使得进程之间的隔离有一点点松动**

- 我们的例子即包含了一个由两个进程显式共享的页帧。
  - 进程A的页5和进程B的页1都指向物理页帧5
- 这种情况是可能的, 因为两个虚拟地址空间中的页(虽然在不同的位置)可以映射到同一物理内存页。
- 由于内核负责将虚拟地址空间映射到物理地址空间,因此可以决定哪些内存区域在进程之间共享,哪些不共享。

**并非虚拟地址空间的所有页都映射到某个页帧。**如图1-6表明：

- 可能是因为页没有使用
- 可能是数据尚不需要使用而没有载入内存中
- 可能是页已经换出到硬盘,将在需要时再换回内存。

**最后请注意, 称呼用户运行的应用程序时, 有两个等价的名词可用。**

其中之一是***用户层 (userland)*** , BSD社区更喜欢使用该术语来称呼所有不属于内核的东西。另一种说法是称某个应用程序在***用户空间***运行。

应该注意到,用户层这个名词总是指应用程序本身,而用户空间则不仅可以表示应用程序,还指代了应用程序所运行的虚拟地址空间的一部分,与内核空间相对。

# 4. 页表

**用来将虚拟地址空间映射到物理地址空间的数据结构称为页表。**

实现两个地址空间的关联最容易的方法是使用数组, 对虚拟地址空间中的每一页, 都分配一个数组项，该数组项指向与之关联的页帧。

> 但有一个问题。例如, IA-32体系结构使用4 KiB页, 在虚拟地址空间为4 GiB的前提下, 则需要包含100 万项的数组。
>
> 在64位体系结构上,情况会更糟糕。
>
> 每个进程都需要自身的页表,因此系统的所有内存都要用来保存页表,也就是说这个方法是不切实际的。

因为虚拟地址空间的大部分区域都没有使用, 因而也没有关联到页帧,那么就可以使用功能相同但内存用量少得多的模型:**多级分页**。

为减少页表的大小并容许忽略不需要的区域, 计算机体系结构的设计会将虚拟地址划分为多个部分,如图1-7所示。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=ODcwNTYxYzM0NjRkODZkMDFlMWNjY2FkMmUyYzE0NmFfZmdQZEdEdDBRV0pTdG1hOG9ydGRQMko5OXBnOTdSUjZfVG9rZW46WER0bWJLaHBib0Y3dmV4TlRWemNQQmtSbndjXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

在例子中,我将虚拟地址划分为4部分,这样就需要一个三级的页表。

> 大多数体系结构都是这样的做法。但有一些采用了四级的页表,而Linux也采用了四级页表。为简化场景, 我在这里会一直用三级页表阐述。

- 虚拟地址的第一部分称为全局页目录(Page Global Directory,PGD)
  - PGD用于索引进程中的一个数组(每个进程有且仅有一个) ,该数组是所谓的全局页目录或PGD
  - PGD的数组项指向另一些数组的起始地址,这些数组称为中间页目录(Page Middle Directory,PMD) 
- 虚拟地址中的第二个部分称为PMD
  - 在通过PGD中的数组项找到对应的PMD之后,则使用PMD 来索引PMD。
  - PMD的数组项也是指针,指向下一级数组,称为页表或页目录
- 虚拟地址的第三个部分称为PTE(Page Table Entry,页表数组)
  - 用作页表的索引。
  - 虚拟内存页和页帧之间的映射就此完成,因为页表的数组项是指向页帧的。
- 虚拟地址最后的一部分称为偏移量
  - 它指定了页内部的一个字节位置。
  - 归根结底,每个地址都指向地址空间中唯一定义的某个字节

**页表的一个特色,也可以说是一个优点，或者说页表解决了什么问题。**

对虚拟地址空间中不需要的区域,不必创建中间页目录或页表。这使得节约了大量的内存空间，避免去存储没有被使用或无意义的页表。

与前述使用单个数组的方法相比,多级页表节省了大量内存。

**但是该方法也有一个缺点。**

每次访问内存时,必须逐级访问多个数组才能将虚拟地址转换为物理地址。

CPU试图用下面两种方法加速该过程：

1. CPU中有一个专门的部分称为MMU(Memory Management Unit,内存管理单元) ,该单元优化了内存访问操作
2. 地址转换中出现最频繁的那些地址,保存到称为地址转换后备缓冲器(Translation Lookaside Buffer,TLB)的CPU高速缓存中。

> 无需访问内存中的页表即可从高速缓存直接获得地址数据,因而大大加速了地址转换。

在许多体系结构中高速缓存的运转是透明的, 但某些体系结构则需要内核专门处理。

这更意味着每当页表的内容变化时必须使TLB高速缓存无效。

内核中凡涉及操作页表之处都必须调用相应的指令。如果针对不需要此类操作的体系结构编译内核,则相应调用自动变为空操作。

## 4.1 与CPU的交互

IA-32体系结构在将虚拟地址映射到物理地址时,只使用了两级页表。

而64位体系结构(Alpha、Sparc64、IA - 64等)地址空间比较大,需要三级或四级的页表,内核与体系结构无关的部分总是假定使用四级页表。

对于只支持二级或三级页表的CPU来说, 内核中体系结构相关的代码必须通过空页表对缺少的页表进行仿真。因此,内存管理代码剩余部分的实现是与CPU无关的。

## 4.2 内存映射

**内存映射是一种重要的抽象手段。**

1. 在内核中大量使用,也可以用于用户应用程序。
2. 映射方法可以将任意来源的数据传输到进程的虚拟地址空间中。
   1. 作为映射目标的地址空间区域,可以像普通内存那样用通常的方法访问。
   2. 但任何修改都会自动传输到原数据源。
3. 这样就可以使用相同的函数来处理完全不同的目标对象。
   1. 例如, 文件的内容可以映射到内存中。 处理只需读取相应的内存即可访问文件内容, 或向内存写入数据来修改文件的内容。
   2. 内核将保证任何修改都会自动同步到文件中。

内核在实现设备驱动程序时直接使用了内存映射，外设的输入/输出可以映射到虚拟地址空间的区域中。

故对相关内存区域的读写会由系统重定向到设备,因而大大简化了驱动程序的实现。

# 5. 物理内存的分配

**在内核分配内存时,必须记录页帧的已分配或空闲状态,以免两个进程使用同样的内存区域。**

- 由于内存分配和释放非常频繁,内核还必须保证相关操作尽快完成。
- 内核可以只分配完整的页帧。
- 将内存划分为更小的部分的工作,则委托给用户空间中的标准库。
- 标准库将来源于内核的页帧拆分为小的区域,并为进程分配内存。

## 5.1 伙伴系统

**内核中很多时候要求分配连续页，****为快速检测内存中的连续区域****,内核采用了一种古老而历经检验的技术:伙伴系统。**

系统中的空闲内存块总是两两分组, 每组中的两个内存块称作伙伴。

- 伙伴的分配可以是彼此独立的。
- 但如果两个伙伴都是空闲的,内核会将其合并为一个更大的内存块,作为下一层次上某个内存块的伙伴。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWEzNWIxNzA5ZTdlZGY4NWMyMzE4YmE2N2I1MzIxYjVfeFdJVTZ3eU93Vkd2UVphOWlEV0JtYkl5OWczNHNBRnZfVG9rZW46UndKQ2JQR0h1b2ZIRGZ4U0VpTmNOcWlpbm1oXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

> 图1-8示范了该系统,图中给出了一对伙伴,初始大小均为8页。
>
> 核对所有大小相同的伙伴(1、2、4、8、16或其他数目的页) ,都放置到同一个列表中管理。 各有8页的一对伙伴也在相应的列表中。
>
> 如果系统现在需要8个页帧,则将16个页帧组成的块拆分为两个伙伴。
>
> 其中一块用于满足应用程序的请求,而剩余的8个页帧则放置到对应8页大小内存块的列表中。
>
> 如果下一个请求只需要2个连续页帧,则由8页组成的块会分裂成2个伙伴,每个包含4个页帧。
>
> 其中一块放置回伙伴列表中,而另一个再次分裂成2个伙伴,每个包含2页。其中一个回到伙伴系统,另一个则传递给应用程序。

**应用程序释放内存时，内核可以直接检查地址,来判断是否能够创建一组伙伴**,并合并为一个更大的内存块放回到伙伴列表中, 这刚好是内存块分裂的逆过程。

这提高了较大内存块可用的可能性。

**在系统长期运行时,服务器运行几个星期乃至几个月是很正常的,许多桌面系统也趋向于长期开机运行,那么会发生称为碎片的内存管理问题。**

- 频繁的分配和释放页帧可能导致一种情况:系统中有若干页帧是空闲的,但却散布在物理地址空间的各处。
  - 换句话说,系统中缺乏连续页帧组成的较大的内存块,而从性能上考虑,却又很需要使用较大的连续内存块。
- 通过伙伴系统可以在某种程度上减少这种效应,但无法完全消除。
  - 如果在大块的连续内存中间刚好有一个页帧分配出去,很显然这两块空闲的内存是无法合并的。

在内核版本2.6.24开发期间,增加了一些有效措施来防止内存碎片,我会在第3章更详细地讨论相关的底层实现机制。

## 5.2 slab缓存

**内核本身经常需要比完整页帧小得多的内存块。**

- 由于内核无法使用标准库的函数,因而必须在伙伴系统基础上自行定义额外的内存管理层,将伙伴系统提供的页划分为更小的部分。
- 该方法不仅可以分配内存, 还为频繁使用的小对象实现了一个一般性的缓存——slab缓存。

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=NjY5NWVlMWY2OTM0OTI0M2M2MGEwMzczOGExZjRlOGFfUEtLallrWnNIeUxWQ2hFMFpNVDVQcW8xVzdrNjVJSW1fVG9rZW46WG5yUWJPNDRib3NFZzN4bU9pSGNKTnAwbmpmXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

**它可以用两种方法分配内存：**

- 对频繁使用的对象,内核定义了只包含了所需类型对象实例的缓存。

*每次需要某种对象时, 可以从对应的缓存快速分配(使用后释放到缓存) 。slab缓存自动维护与伙伴系统的交互,在缓存用尽时会请求新的页帧*

- 对通常情况下小内存块的分配,内核针对不同大小的对象定义了一组slab缓存,可以像用户空间编程一样,用相同的函数访问这些缓存。

*不同之处是这些函数都增加了前缀k,表明是与内核相关联的:kmalloc和kfree。*

> 虽然slab分配器在各种工作负荷下的性能都很好,但在真正规模庞大的超级计算机上使用时,出现了一些可伸缩性问题。
>
> 另一方面,对真正微小的嵌入式系统来说,slab分配器的开销可能又太大了。

内核提供了slab分配器的两种备选方案, 可用于在相应的场景下替换slab分配器并提供更好的性能。

对内核的其他部分而言,这3种方案的接口相同,因而不必关注内核中实际编译进来的底层分配器是哪一个。

由于slab分配仍然是内核的标准方法,因此我不会详细讨论备选方案。

## 5.3 页面交换和页面回收

**页面交换通过利用磁盘空间作为扩展内存,从而增大了可用的内存。**

- 在内核需要更多内存时,不经常使用的页可以写入硬盘。
- 如果再需要访问相关数据,内核会将相应的页切换回内存。

> 通过缺页异常机制,这种切换操作对应用程序是透明的，换出的页可以通过特别的页表项标识。
>
> 在进程试图访问此类页帧时,CPU则启动一个可以被内核截取的缺页异常，此时内核可以将硬盘上的数据切换到内存中。
>
> 接下来用户进程可以恢复运行。
>
> 由于进程无法感知到缺页异常,所以页的换入和换出对进程是完全不可见的。

**页面回收用于将内存映射被修改的内容与底层的块设备同步,为此有时也简称为数据回写。**

- 数据刷出后,内核即可将页帧用于其他用途(类似于页面交换)。
- 内核的数据结构包含了与此相关的所有信息,当再次需要该数据时,可根据相关信息从硬盘找到相应的数据并加载。

# 6. 计时

**内核必须能够测量时间以及不同时间点的时差,进程调度就会用到该功能。**

- jiffies是一个合适的时间坐标。
- 名为jiffies_64和jiffies(分别是64位和32位)的全局变量,会按恒定的时间间隔递增。
- 每种计算机底层体系结构都提供了一些执行周期性操作的手段,通常的形式是定时器中断。
- 对前述的两个全局变量的更新可使用底层体系结构提供的各种定时器机制执行。

**jiffies递增的频率同体系结构有关**

- 取决于内核中一个主要的常数HZ。
- 该常数的值通常介于100 和1 000中间。
- 换言之,jiffies的值每秒递增的次数在100至1 000次之间。

**基于jiffies的计时相对粒度较粗。**

- 因为目前1 000 Hz已经算不上很高的频率了。
- 在底层硬件能力允许的前提下,内核可使用高分辨率的定时器提供额外的计时手段,能够以纳秒级的精确度和分辨率来计量时间。

**计时的周期是可以动态改变的**

- 在没有或无需频繁的周期性操作的情况下,周期性地产生定时器中断是没有意义的,这会阻止处理器降低耗电进入睡眠状态。
- 动态改变计时周期对于供电受限的系统是很有用的,例如笔记本电脑和嵌入式系统。

# 7. 系统调用

**系统调用是用户进程与内核交互的经典方法。**

POSIX标准定义了许多系统调用,以及这些系统调用在所有遵从POSIX的系统包括Linux上的语义。传统的系统调用按不同类别分组,如下所示：

- **进程管理**:创建新进程,查询信息,调试。 >>
- **信号**:发送信号,定时器以及相关处理机制。 >>
- **文件**:创建、打开和关闭文件,从文件读取和向文件写入,查询信息和状态。 >>
- **目录和文件系统**:创建、删除和重命名目录,查询信息,链接,变更目录。 >>
- **保护机制**:读取和变更UID/GID,命名空间的处理。 >>
- **定时器函数**:定时器函数和统计信息。

**所有这些函数都对内核提出了要求。**

1. 这些函数不能以普通的用户库形式实现,因为需要特别的保护机制来保证系统稳定性或安全不受危及。
2. 此外许多调用依赖内核内部的结构或函数来得到所需的数据或结果,这也导致了无法在用户空间实现。
3. 在发出系统调用时,处理器必须改变特权级别,从用户状态切换到核心态。

> Linux对此没有标准化的做法,因为每个硬件平台都提供了特定的机制。
>
> 有时候, 在同样的体系结构上也会根据处理器类型使用不同的方法实现。
>
> 尽管Linux使用了一个专用软件中断在IA-32处理器上执行系统调用,而其他UNIX操作系统在IA-32上的软件仿真(iBCS仿真器)则采用了一种不同的方法来执行二进制程序(汇编语言爱好者会知道,是lcall7或lcall27调用门)。
>
> IA-32 架构的现代处理器也提供了专用的汇编语句来执行系统调用，这在旧系统上是不可用的,因此无法用到所有计算机上。

对所有的处理器来说,一个共同点就是:用户进程要从用户状态切换到核心态,并将系统关键任务委派给内核执行,系统调用是必由之路。

# 8. 设备驱动程序、块设备和字符设备

**设备驱动程序用于与系统连接的输入/输出装置通信**

设备驱动程序用于与系统连接的输入/输出装置通信,如硬盘、软驱、各种接口、声卡等。

按照经典的UNIX箴言"**万物皆文件" (everything is a file)** ,对外设的访问可利用/dev目录下的设备文件来完成,程序对设备的处理完全类似于常规的文件。

设备驱动程序的任务在于支持应用程序经由设备文件与设备通信。换言之,使得能够按适当的方式在设备上读取/写入数据。

**外设可分为以下两类：**

1. 字符设备
   1. 提供连续的数据流,应用程序可以顺序读取。
   2. 通常不支持随机存取，相反,此类设备支持按字节/字符来读写数据。
   3. 举例来说,调制解调器是典型的字符设备。
2. 块设备
   1. 应用程序可以随机访问设备数据,程序可自行确定读取数据的位置。

硬盘是典型的块设备,应用程序可以寻址磁盘上的任何位置,并由此读取数据。

1. 此外,数据的读写只能以块(通常是512B)的倍数进行。
2. 与字符设备不同,块设备并不支持基于字符的寻址。

编写块设备的驱动程序比字符设备要复杂得多,因为内核为提高系统性能广泛地使用了缓存机制。

# 9. 网络

**网卡也可以通过设备驱动程序控制, 但在内核中属于特殊状况, 因为网卡不能利用设备文件访问。**

原因在于在网络通信期间,数据打包到了各种协议层中。

- 在接收到数据时,内核必须针对各协议层的处理,对数据进行拆包与分析,然后才能将有效数据传递给应用程序。
- 在发送数据时,内核必须首先根据各个协议层的要求打包数据,然后才能发送。

**为支持通过文件接口处理网络连接 (按照应用程序的观点) , Linux使用了源于BSD的套接字抽象。**

套接字可以看作应用程序、文件接口、内核的网络实现之间的代理。

# 10. 文件系统

**Linux系统由数以千计乃至百万计的文件组成,其数据存储在硬盘或其他块设备。**

- 存储使用了层次式文件系统。
- 文件系统使用目录结构组织存储的数据,并将其他元信息(例如所有者、访问权限等)与实际数据关联起来。

**Linux支持许多不同的文件系统**

标准的Ext2 和Ext3文件系统、ReiserFS、XFS、VFAT(为兼容DOS) ,还有很多其他文件系统。

> 不同文件系统所基于的概念抽象,在某种程度上可以说是南辕北辙。
>
> Ext2基于inode,即它对每个文件都构造了一个单独的管理结构,称为inode,并存储到磁盘上。
>
> inode包含了文件所有的元信息,以及指向相关数据块的指针。
>
> 目录可以表示为普通文件,其数据包括了指向目录下所有文件的inode的指针,因而层次结构得以建立。
>
> 相比之下,ReiserFS广泛应用了树形结构来提供同样的功能。

**内核必须提供一个额外的软件层,将各种底层文件系统的具体特性与应用层(和内核自身)隔离开来。**

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFkZDRlZTM4NWJiMGJhMmE3ZDZhOGExZWJlMTkxZGNfb3V2RFhnWFBQZGwzbzlSVGk2QWJ4bVBNampaRjN2alVfVG9rZW46TTZEbWI2MDdPb1J0N1Z4b2QyYWNZQVIzbldoXzE3MDU1MDY4MTQ6MTcwNTUxMDQxNF9WNA)

- 该软件层称为VFS(Virtual Filesystem或Virtual Filesystem Switch,虚拟文件系统或虚拟文件系统交换器)
- VFS既是向下的接口(所有文件系统都必须实现该接口) ,同时也是向上的接口(用户进程通过系统调用最终能够访问文件系统功能) 。

# 11. 模块和热插拔

**模块用于在运行时动态地向内核添加功能。**

- 如设备驱动程序、文件系统、网络协议等,实际上内核的任何子系统几乎都可以模块化。
- 这消除了宏内核与微内核相比一个重要的不利之处。

**模块还可以在运行时从内核卸载,这在开发新的内核组件时很有用。**

**模块在本质上不过是普通的程序,只是在内核空间而不是用户空间执行而已。**

- 模块必须提供某些代码段在模块初始化(和终止)时执行,以便向内核注册和注销模块。
- 模块代码与普通内核代码的权利(和义务)都是相同的,可以像编译到内核中的代码一样,访问内核中所有的函数和数据。

**对支持热插拔而言,模块在本质上是必需的。**

某些总线(例如,USB和FireWire)允许在系统运行时连接设备,而无需系统重启。

在系统检测到新设备时,通过加载对应的模块,可以将必要的驱动程序自动添加到内核中。

**模块特性使得内核可以支持种类繁多的设备, 而内核自身的大小却不会发生膨胀。**

在检测到连接的硬件后,只需要加载必要的模块,多余的驱动程序无需加入到内核。

**内核社区中一个长期存在的争论则是围绕只提供二进制代码的模块展开的, 即不提供源代码的模块**

*在大多数私有的操作系统上只提供二进制代码的模块是普遍存在的,但许多内核开发者认为它们(至少是)邪恶的化身。内核是开源软件,因此他们认为,出于各种法律和技术原因,模块也应该是开源的。实际上还有更有力论据支持上述推论(此外,我也这样认为),但一些商业公司不这样看, 他们认为开放驱动程序的源代码会削弱其商业地位。*

*目前可以将只提供二进制代码的模块加载到内核,但有很多限制。最重要的一点是,对任何明确规定调用者也必须使用GPL许可的函数,此类模块均不能访问。加载只提供二进制代码的模块会污染内核,每当发生点坏事,过错自然会归咎于相应的模块。如果内核被污染,则故障转储文件中会标记出来,而内核开发者一般不愿意解决此类导致崩溃的问题。因为二进制模块可能使内核的每个部分都发生了充分的震荡,不能假定内核仍然可以按预定的设计工作,所以这种情况下的支持工作最好留给相关模块的厂商处理。*

**加载只提供二进制代码的模块, 并不是污染内核的唯一可能原因**

如果计算机经历了某些严重的异常情况,也可能导致内核被污染。

例如,使用由于规格或其他原因而无法支持多处理器的CPU来构建SMP系统。

# 12. 缓存

**内核使用缓存来改进系统性能。**

1. 从低速的块设备读取的数据会暂时保持在内存中,即使数据在当时已经不再需要了。

在应用程序下一次访问该数据时,它可以从访问速度较快的内存中读取,因而绕过了低速的块设备。

1. 由于内核是通过基于页的内存映射来实现访问块设备的,因此缓存也按页组织, 也就是说整页都缓存起来,故称为页缓存(page cache)。

块缓存用于缓存没有组织成页的数据,其重要性差得多。

> 在传统的UNIX系统上,块缓存用作系统的主缓存,而Linux很久以前也是这样。到如今,块缓存已经被页缓存取代了。