# 可用的系统调用

在深入讨论内核（和用户空间库）如何实现系统调用的技术细节之前，简要看一下内核以系统调用形式实际提供的各个函数是很有用处的。

每个系统调用都通过一个符号常数标识，符号常数的定义是平台相关的，在 <asm-arch/unis-td.h> 中指定。因为并非所有体系结构都支持所有的系统调用（有些组合是无意义的），不同的平台上可用调用的数目会有一定的不同，粗略地说，总共有200多个系统调用。随着时间的流逝，内核对系统调用实现的各种更改使得一些调用现在是多余的，其编号现在已经不再使用。Linux在Sparc（32位处理器）上的移植版本就有很多废弃的系统调用，在调用编号列表中形成了“缺口”。

下面简单列出（并不完备）了各种功能类别的概述，以及其中最重要的系统调用。

# 1. 进程管理

进程处于系统的中心，因此进程管理方面有大量系统调用。这些系统调用提供的功能很多，从查询简单的信息，到启动新进程，等等。

- **fork 和 vfork** 将一个现存进程分支为两个新进程，如第2章所述。 clone 是 fork 的增强版，除了具有 fork 的功能，还支持创建线程。
- **exit** 结束一个进程并释放其资源。
- **setXXX**：有一大堆系统调用可用于查询（和设置）进程的属性，诸如 setgid 、 setuid 和 geteuid等，其中大多数调用只是读取或修改 task_struct 中的字段而已，如PID、UID、等等。
  - 可以读取下列属性：PID、GID、PPID、SID、UID、EUID、PGID、EGID、PGRP。
  - 可以设置下列属性：UID、GID、REUID、REGID、SID、SUID和FSGID。
- **personality** 定义了应用程序的执行环境，例如，可用于二进制仿真的实现。
- **ptrace** 使得能够跟踪系统调用，它是 strace 工具的基础。
- **nice** 设置普通进程的优先级，它给进程分配的优先级在20和19之间，随数值的升高优先级递减。只有 root 进程（或有 CAP_SYS_NICE 权限的进程）才能指定负的优先级值。
- **setrlimit** 用于设置一定的资源限制，例如，CPU时间或子进程的最大容许数目。 getrlimit查询当前的限制（即允许的最大值），而 getrusage 查询当前资源使用情况，检查进程是否合乎定义的资源限制。

# 2. 时间操作

时间操作很关键，不仅可用来查询和设置当前系统时间，还使进程能够执行基于时间的操作，如第15章所述。

- **adjtimex** 读取和设置基于时间的内核变量，以控制内核在时间方面的行为。
- **alarm** **和** **setitimer** 建立报警器和间隔定时器，将操作延迟到一个稍后的时间执行。 getitimer读取设置。
- **gettimeofday** **和 settimeofday** 分别获取和设置当前系统时间。与 time 不同，这两个函数还考虑了当前时区和夏令时的因素。
- **sleep** 和 **nanosleep** 让进程执行暂停一个指定的时间段。 nanosleep 可以高精度的时间单位来指定暂停的时间段。
- **time** 返回自1970年1月1日零时（这个日期是UNIX系统经典的时间基线）以来经过的秒数。
- **stime** 设置这个值，因而也会改变当前系统的日期。

# 3. 信号处理

信号是在进程之间交换有限信息以及促进进程间通信的最简单（也最古老）的方法。Linux不仅支持所有类UNIX系统所共有的经典信号，还支持实时信号，这与POSIX标准是一致的。第5章阐述了信号机制的实现。

- signal 设置信号处理函数。 sigaction 是 signal 的现代增强版本，支持附加的选项，并提供了更大的灵活性。
- sigpending 检查进程当前是否有待决信号被阻塞。
- sigsuspend 将进程置于等待队列上，直至某个特定（一组信号中的一个）的信号到达。
- setmask 启用信号的阻塞机制，而 getmask 返回所有当前阻塞信号的列表。
- kill 用于向一个进程发送任何信号。
- 还有一组处理实时信号的系统调用，但其对应的函数名带有前缀 rt_ 。例如， rt_sigaction设置一个实时信号处理程序，而 rt_sigsuspend 将进程置于等待状态，直至某个特定（一组信号中的一个）信号到达。

与传统信号机制相比，所有体系结构（即使是32位CPU）都可以处理64个不同的实时信号。实时信号可以关联附加信息，这使得（应用）程序员的工作稍微容易些。

# 4. 调度

与调度相关的系统调用可以归类到进程管理，因为所有此类调用都与系统进程有关。之所以值得建立一个独立的类别，只是因为Linux在进程行为的参数化方面，提供了大量的操作选项。

- **setpriority 和 getpriority** 分别设置和获取进程的优先级，因而是用于调度目的的关键系统调用。
-  **sched_setscheduler和 sched_getscheduler**分别设置和查询调度类。sched_setparam 和 sched_getparam 分别设置和查询进程的附加调度参数（当前，只使用了实时优先级的参数）。
  - 请注意，Linux不仅支持不同的进程优先级，还提供了多种调度类，以适应应用程序在时间方面具体的行为和需求。
- **sched_yield**自愿释放CPU的控制权，即使进程当前仍然有CPU时间可用。

# 5. 模块

系统调用还用于向内核增加模块和从内核移除模块，如第7章所述。

- init_module 添加一个新模块。
- delete_module 从内核移除一个模块。

# 6. 文件系统

所有关于文件系统的系统调用都应用到VFS层的例程，如第8章所述。从VFS层开始，各个调用转发到具体文件系统的实现，后者通常会访问块层。从资源和执行时间来衡量，此类系统调用的代价都很高。

- 一些系统调用被用作用户空间中同名实用程序的直接基础，用来创建和修改目录结构： chdir 、mkdir 、 rmdir 、 rename 、 symlink 、 getcwd 、 chroot 、 umask 和 mknod 。
- 文件和目录属性可以用 chown 和 chmod 修改。
- 下列实用程序用于处理文件内容，其实现在标准库中，与对应的系统调用同名： open 、 close 、read 与 readv 、 write 与 writev 、 truncate 和 llseek 。
- readdir 和 getdents 读取目录结构。
- link 、 symlink 和 unlink 创建和删除链接（或文件，如果该文件是某个硬链接的最后一个成员）。 readlink 读取链接的内容。
- mount 和 umount 用于文件系统的装载和卸载。
- poll 和 select 用于等待某些事件。
- execve 装载一个新进程，替换旧的进程。在与 fork 联合使用时，它会启动一个新的程序。

# 7. 内存管理

在通常的环境下，用户应用程序很少或从未接触到内存管理系统调用，因为这个领域被标准库的API屏蔽起来了，C标准库提供了 malloc 、 balloc 和 calloc 等函数。实现通常与编程语言相关，因为每种语言都有不同的动态内存管理需求，还经常会提供垃圾收集这样的特性，需要对内核提供的内存进行精巧而复杂的分配。

- 就动态内存管理而言，最重要的调用是 brk ，它修改进程数据段的长度。调用了 malloc 或相似函数的程序（几乎所有非平凡的代码，都符合这个条件）会频繁使用该系统调用。
- mmap 、 mmap2 、 munmap 和 mremap 执行内存映射、解除映射和重新映射操作，而 mprotect 控制对虚拟内存中特定区域的访问， madvice 提出对特定虚拟内存区域的使用建议。
  - mmap 和 mmap2 的参数稍有不同，更多细节请参考手册页。默认情况下，GNU C库使用 mmap2 ；现在 mmap 只是一个用户层包装器函数。
  - 根据 malloc 的实现，它在内部可以使用 mmap 或 mmap2 。这是可行的，因为匿名映射允许建立没有文件作为后备存储的映射。与使用 brk 相比，该方法更加灵活。
- swapon 和 swapoff 分别启用和禁用外存储器设备上（附加）的交换区。

# 8. 进程间通信和网络功能

因为“进程间通信（IPC）和网络”是比较复杂的问题，很容易臆断有大量相关的系统调用。但根据第12章和第5章所述，事实刚好相反。只有两个系统调用来处理所有可能的任务。但其中涉及了非常多的参数。C标准库将这些功能安排到许多不同的函数，这些函数只有少量参数，使得程序员更容易处理。最终，这些函数总是基于下面两个系统调用。

- **socketcall** 处理网络方面的问题，用于实现套接字抽象。它管理各种类型的连接和协议，总共实现了17种功能，通过 SYS_ACCEPT 、 SYS_SENDTO 等常数来区分。参数必须以指针形式传递，指向一个与函数类型相关的用户空间结构，其中保存了所需的数据。
- **ipc** 与 socketcall 相对应，用于处理计算机本地的连接，而不是通过网络建立的连接。因为该系统调用“只”需要实现11种功能，它使用了固定数目的参数来从用户空间向内核空间传递数据，总共是5个。

# 9. 系统信息和设置

通常必需查询当前运行内核及其配置和系统配置的有关信息。类似地，需要设置内核参数，有些信息必须保存到系统日志文件。内核提供了下列3个系统调用来执行此类任务。

- syslog 向系统日志写入消息，并允许设置不同的优先级（根据消息的优先级不同，用户空间工具或者向持久性的日志文件发送消息，或者直接向控制台输出消息以通知用户某些关键情况。
- sysinfo 返回有关系统状态的信息，特别有关内存使用的统计量（物理内存、缓冲区、交换区）。
- sysctl 用于“微调”内核参数。内核现在支持大量的动态可配置选项，可以使用 proc 文件系统读取和修改，如第10章所述。

# 10. 系统安全和能力

传统的UNIX安全模型基于用户、组和一个“万能的”root用户，对现代需求而言已经不够灵活。这就导致引入了能力系统，该系统根据细粒度方案，使得非root进程能够拥有额外的权限和能力。

此外，LSM（Linux security modules，Linux安全模块）子系统提供了一个通用接口，支持内核在各个位置通过挂钩调用模块函数来执行安全检查。

- capset 和 capget 负责设置和查询进程的能力。
- security 是一个系统调用的多路分解器，用于实现LSM。