# 系统程序设计基础

# 1. 前言

从用户程序的角度来看，内核是一个透明的系统层，它一直存在，但从未真正被注意到。

进程不知道内核是否在运行中。进程同样不知道虚拟内存的哪些内容在物理内存中，哪些已经换出或尚未读入。但进程一直忙于与内核的交互：请求系统资源、访问外设、与其他进程通信、读取文件等。为了达到上述目的，进程使用标准库例程，库例程接下来调用内核函数，最终，由内核负责在各个请求进程之间公平而且流畅地共享资源和服务。

因而，应用程序看到的内核是负责执行多种系统功能的一个大的例程集合。

**标准库是一个中间层，用于在不同的体系结构和系统之间，标准化并简化内核例程的管理**。

从内核的视角来看，情况当然有一点复杂，因为用户态和核心态之间有几个重大的不同，有一些不同已经在本书前几章中讨论过。要特别注意两种模式下不同的虚拟地址空间和利用各种处理器特性的不同方式。另外，我们还比较感兴趣的一点是，控制权如何在应用程序和内核之间来回传递，参数和返回值如何传递。

**本章将讨论这些问题按前几章的讨论，系统调用用于从用户应用程序调用内核例程，以利用内核的一些专门的功能**。我们已经考察了很多内核子系统的系统调用的实现。

本章首先简要地看一下系统程序设计，把标准库的库例程和对应的系统调用区分清楚。接下来仔细考察内核源代码，以描述用于从用户空间切换到内核空间的机制。我们将描述用于实现系统调用的基础设施，并讨论特别的实现方面的特性。

# 2. 系统程序设计介绍

大体上，系统程序设计主要是利用标准库进行工作，标准库提供了各种基本函数，用于开发应用程序。无论编写何种应用程序，程序员都必须了解系统程序设计的基础知识。

## 2.1 系统调用引言

一个简单的程序，如经典的 hello.c 例程，在屏幕上显示“Hello, world!”或类似的文本，也会间接使用系统例程来输出必要的字符。

当然，系统程序设计不一定总是用C语言。还有其他编程语言，如C++、Pascal、Java，甚至令人讨厌的FORTRAN也或多或少地支持直接使用外部库的例程，因而也能够调用标准库函数。但通常会使用C语言编写系统程序，因为它与UNIX概念融合得最好，所有的UNIX内核都是用C语言编写的，Linux也不例外。

标准库不仅是实现内核系统调用的接口集合，其中也提供了许多其他完全在用户空间实现的函数。这简化了程序员的工作，使得程序员不需要一直“重新发明轮子”。而GNU C库中的大约100 MiB代码，肯定是能用得上的。

## 2.2 系统程序对细节的关注

因为通用编程语言正在向越来越高的抽象层次发展，而系统程序设计的真正意义正在被缓慢地侵蚀。在用鼠标点击几下，就能毫不费力地创建一个程序时，为什么还要费心关注系统细节呢？

这里需要的是一条中间道路。对一个用于在文本文件中扫描某个字符串的简单Perl脚本来说，不太可能去费力深究打开和读取文本文件的机制。在这种情况下，只需要知道数据总会以某种方式从文件读取出来，这种实用主义的看法就足够了。但在另一方面，包含上G或上T字节数据的数据库当然想要知道用于访问其文件或裸数据的底层操作系统机制，以便对数据库代码进行调优，从而提供最高的性能。

向内存中的一个巨型矩阵提供特定的值就是一个经典的例子，我们从中可以看到，通过考察操作系统的内部结构，如何来极大地提高程序的性能。如果上述矩阵的数据散布在几个内存页面上，那么向矩阵提供值的顺序就非常关键。

根据内存管理子系统管理内存的方式，可以避免不必要的调页操作，并且能够最有效地使用系统的缓存和缓冲区。

本章讨论的技术并未从内核的功能抽象出来（至少抽象程度不高），这更使得我们需要考察内核的内部结构和架构上的一些原则，包括对外部的接口。

# 3. 追踪系统调用

### 3.1 一个简单的例子

下列例子展示了如何使用标准库的包装器例程来进行系统调用：

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmZjODk1NGU1Mjc3MWM3NDc4MjNmYTAyZWM0YzI1ZWNfNXM3UEFrQURua0gzeExZcURpRXlmQ3lyaVhBYjNkUUtfVG9rZW46QzhZaWJCM1VvbzVwanp4TzdNZmNuelFRbnplXzE3MDQ5ODIwNzg6MTcwNDk4NTY3OF9WNA)

这个示例程序打开文件 /tmp/test.txt ，读取前150个字节，并将其写到标准输出，这是UNIX head 命令的一个非常简单的版本。

### 3.2 跟踪系统调用

这个程序使用了多少个系统调用呢？能直接看到的只有 open 、 read 和 close （其实现在第8章讨论过）。

而 printf 函数也是通过系统调用在标准库中实现的。当然可以阅读标准库的代码，来看看具体使用了哪个系统调用，但这肯定是冗长乏味的。

一个简单些的方案是使用 **strace** 工具，它可以记录应用程序发出的所有系统调用并将该信息提供给程序员，在调试程序时，这个工具是不可缺少的。内核自然需要为记录系统调用提供专门的支持，这将在13.3.3节讨论［不出所料，这项支持功能也是一个系统调用（ptrace），我们只对其输出感兴趣］。

接下来使用 strace 命令将 shead （上述的例子程序）发出的所有系统调用的列表写到 log.txt 中： ①

`wolfgang@meitner> `**`strace -o log.txt ./shead`**

log.txt 的内容比读者的预期可能要多很多：

![img](https://p2onpu7kg4.feishu.cn/space/api/box/stream/download/asynccode/?code=YjcwYjg1OTU1YjdlYmFiNzBlZDQ4M2IxYjY2ZWZjYzdfdHZWWXZkSGlOT3NCM3VvYkRESWZsQmJDc2J1Z3JwcVhfVG9rZW46Qjd0aGJXNmlwb0xRZGp4TzVLaGN6VERZbjRnXzE3MDQ5ODIwNzg6MTcwNDk4NTY3OF9WNA)